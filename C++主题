我来谈谈历史好了
大多数人所谓的 OOP，其实都是说的「继承封装多态」这一套，但是，最早的 OOP,叫对象范式，对象范式的两个基本观念：
*.程序是由对象组成的；
*.对象之间互相发送消息，协作完成任务
请问，有「继承封装多态」的定义吗？没有！！！
这两个观念与后来我们熟知的面向对象三要素「封装、继承、多态」根本不在一个层面上。倒是与再后来的「组件、接口」神合。​​
世界上第一个面向对象语言是 Simula-67，第二个面向对象语言是 Smalltalk-71。Smalltalk 受到了 Simula-67 的启发，基本出发点相同，但也有重大的不同。
先说相同之处，Simula 和 Smalltalk 都秉承上述对象范式的两个基本观念，为了方便对象的构造，也都引入了类、继承等概念。
也就是说，类、继承这些机制是为了实现对象范式原则而构造出来的第二位的、工具性的机制。
而 Simula 和 Smalltalk 最重大的不同，就是 Simula 用方法调用的方式向对象发送消息，而 Smalltalk 构造了更灵活和更纯粹的消息发送机制。​​
到了 1980 年代，C++出现了。Bjarne Stroustrup 在博士期间深入研究过 Simula，非常欣赏其思想，于是就在 C 语言语法的基础之上，几乎把 Simula 的思想照搬过来，形成了最初的 C++。C++问世以之初，主要用于解决规模稍大的传统类型的编程问题，迅速取得了巨大的成功，也证明了对象范式本身所具有的威力。​​
大约在同期，Brad Cox 根据 Smalltalk 的思想设计了 Objective-C，可是由于其语法怪异，没有流行起来。只有 Steve Jobs 这种具有禅宗美学鉴赏力的世外高人，把它奉为瑰宝，与 1988 年连锅把 Objective-C 的团队和产品一口气买了下来​​
形势使然，C++的广泛使用，大大的影响了学术界，学术界疯狂的热爱继承这套体系，希望利用继承来描述世间的真实类别系统，然而现实世界复杂多了，蝙蝠是鸟也是兽，水上飞机能飞也能游，它们该如何归类呢。这套继承体制遇到真实世界的时候破绽很大，但是学界已经刹不住车了，甚至搞出了多重继承。这股风潮影响了后续的 Java （虽然它没「继承」那套翔一样的多继承机制，引入了接口这个其实更接近 OOP 本质的东西），扭曲了人们对面向对象的理解。既然必须要先知道对象的类型，才能向对象发消息，那么「类」这个概念就特别重要了，而对象只不过是类这个模子里造出来的东西，反而不重要。渐渐的，「面向对象编程」变成了「面向类编程」，「面向类编程」变成了「构造类继承树」。放在眼前的鲜活的对象活动不重要了，反而是其背后的静态类型系统成为关键。「封装、继承」这些第二等的特性，喧宾夺主，俨然成了面向对象的要素。每个程序员似乎都要先成为领域专家，然后成为领域分类学专家，然后构造一个完整的继承树，然后才能 new 出对象，让程序跑起来。​​
到了 1990 年代中期，问题已经十分明显。UML 中有一个对象活动图，其描述的就是运行时对象之间相互传递消息的模型。1994 年 Robert C. Martin 在《 Object-Oriented C++ Design Using Booch Method 》中，曾建议面向对象设计从对象活动图入手，而不是从类图入手。而 1995 年出版的经典作品《 Design Patterns 》中，建议优先考虑组合而不是继承，这也是尽人皆知的事情。这些迹象表明，在那个时候，面向对象社区里的思想领袖们，已经意识到「面向类的设计」并不好用。只可惜他们的革命精神还不够，delphi 之父在创建.net 的时候，曾经不想要继承，在微软内部引起了很大的争议，最后是向市场低头，加上了继承。​​
2000 年后，工程界明确的提出：「组合比继承重要，而且更灵活」，Go 语言也许是第一个明确的对这种思路进行回应的语言，你认为 Go 不够 OOP，那是因为你观点里的 OOP 其实是被扭曲过的，时至今日，学术界仍然很关注继承，但是工程界的思路已经变了，OOP 本质是为了职责分离而设计的范式，核心的东西是对象，不一定需要类，OOP 也不是继承封装多态的代名词
